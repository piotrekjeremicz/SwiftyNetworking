//
//  URLRequest+CustomStringConvertible.swift
//  SwiftyNetworking
//
//  Created by Piotrek Jeremicz on 10.10.2025.
//

#if canImport(Foundation)
import Foundation

// TODO: Refactor - generated by LLM
public extension URLRequest {
    var requestDescription: String {
        let method = httpMethod ?? "GET"

        let url = self.url
        
        let pathAndQuery: String = {
            guard let url else { return "/" }
            var path = url.path.isEmpty ? "/" : url.path
            if let query = url.query, !query.isEmpty {
                path += "?" + query
            }
            return path
        }()

        let httpVersion: String = {
            if #available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *) {
                // URLRequest doesn't expose version; default to HTTP/1.1
                return "HTTP/1.1"
            } else {
                return "HTTP/1.1"
            }
        }()

        var lines: [String] = []
        lines.append("\(method) \(pathAndQuery) \(httpVersion)")

        // Host header
        if let host = url?.host {
            var hostValue = host
            if let port = url?.port {
                hostValue += ":\(port)"
            }
            lines.append("Host: \(hostValue)")
        }

        // Other headers (sorted for stability), excluding Host to avoid duplication
        if let headers = allHTTPHeaderFields, !headers.isEmpty {
            for key in headers.keys.sorted(by: { $0.localizedCaseInsensitiveCompare($1) == .orderedAscending }) {
                if key.caseInsensitiveCompare("Host") == .orderedSame { continue }
                if let value = headers[key] {
                    lines.append("\(key): \(value)")
                }
            }
        }

        // Body
        let bodyString: String? = {
            guard let body = httpBody, !body.isEmpty else { return nil }
            // Try UTF-8 first
            if let utf8 = String(data: body, encoding: .utf8) {
                return utf8
            }
            // Fall back to ISO-8859-1 which is common in HTTP contexts
            if let latin1 = String(data: body, encoding: .isoLatin1) {
                return latin1
            }
            // As a last resort, indicate binary body with byte count
            return "<\(body.count) bytes binary body>"
        }()

        // Content-Length: If not already present and body exists, add it for completeness
        if let body = httpBody, !body.isEmpty {
            let hasContentLength = allHTTPHeaderFields?.keys.contains { $0.caseInsensitiveCompare("Content-Length") == .orderedSame } ?? false
            if !hasContentLength {
                lines.append("Content-Length: \(body.count)")
            }
        }

        // Join headers and add a blank line before body
        var message = lines.joined(separator: "\n")
        message += "\n\n"
        if let bodyString {
            message += bodyString
        }

        return message
    }
}

#endif
